import fs from "node:fs";
import path from "node:path";
import YAML from "yaml";
import SwaggerParser from "@apidevtools/swagger-parser";
import jsf from "json-schema-faker";
import { faker as Faker } from "@faker-js/faker";
import seedrandom from "seedrandom";

type OpenAPI = any;

const SPEC_PATH = path.resolve("api/openapi.yaml");
const OUT_FIXTURES = path.resolve("src/mocks/fixtures");
const OUT_HANDLERS = path.resolve("src/mocks/handlers.ts");

// Настройки: “правдоподобно, но воспроизводимо”
const SEED = process.env.MOCK_SEED ?? "12345";
seedrandom(SEED, { global: true });
Faker.seed(hashSeed(SEED));

// json-schema-faker + faker
jsf.extend("faker", () => Faker);

// Чтобы не генерил гигантские массивы/строки
jsf.option({
  alwaysFakeOptionals: true,
  maxItems: 5,
  minItems: 1,
  useDefaultValue: true,
  useExamplesValue: true, // если в контракте есть examples, они победят faker
  failOnInvalidTypes: false,
  fillProperties: true,
});

main().catch((e) => {
  console.error(e);
  process.exit(1);
});

function hashSeed(s: string) {
  // маленький стабильный хэш, чтобы faker.seed принимал число
  let h = 0;
  for (let i = 0; i < s.length; i++) h = (h * 31 + s.charCodeAt(i)) >>> 0;
  return h;
}

async function main() {
  ensureDir(OUT_FIXTURES);

  const raw = fs.readFileSync(SPEC_PATH, "utf8");
  const parsed = YAML.parse(raw);

  // Dereference: убираем $ref, чтобы генерация схем не сходила с ума
  const api: OpenAPI = await SwaggerParser.dereference(parsed);

  const ops: GeneratedOp[] = collectOperations(api);

  const handlerLines: string[] = [];
  handlerLines.push(`/* eslint-disable */`);
  handlerLines.push(`import { http, HttpResponse } from "msw";`);
  handlerLines.push(``);
  handlerLines.push(`// AUTOGENERATED. Do not edit by hand.`);
  handlerLines.push(`export const handlers = [`);

  for (const op of ops) {
    const fixtureName = `${sanitize(op.operationId)}.json`;
    const fixturePath = path.join(OUT_FIXTURES, fixtureName);

    const data = generateExample(op.responseSchema, op);
    fs.writeFileSync(fixturePath, JSON.stringify(data, null, 2), "utf8");

    const mswPath = toMswPath(op.path);

    // handlers.ts подгружает JSON через import (Vite/webpack обычно умеют)
    handlerLines.push(
      `  http.${op.method.toLowerCase()}("${mswPath}", async () => {`
    );
    handlerLines.push(
      `    const data = (await import("./fixtures/${fixtureName}")).default;`
    );
    handlerLines.push(`    return HttpResponse.json(data);`);
    handlerLines.push(`  }),`);
  }

  handlerLines.push(`];`);
  handlerLines.push(``);

  fs.writeFileSync(OUT_HANDLERS, handlerLines.join("\n"), "utf8");

  console.log(
    `✅ Generated ${ops.length} fixtures into ${OUT_FIXTURES} (seed=${SEED})`
  );
  console.log(`✅ Generated MSW handlers: ${OUT_HANDLERS}`);
}

type GeneratedOp = {
  operationId: string;
  method: string;
  path: string;
  responseSchema: any;
};

function collectOperations(api: OpenAPI): GeneratedOp[] {
  const out: GeneratedOp[] = [];
  const paths = api.paths ?? {};

  for (const [p, methods] of Object.entries<any>(paths)) {
    for (const method of ["get", "post", "put", "patch", "delete"] as const) {
      const op = methods?.[method];
      if (!op) continue;

      const operationId = op.operationId ?? `${method}_${p}`;
      const responseSchema = pickResponseSchema(op);

      // Если схему ответа не нашли, пропускаем (или можешь сделать null)
      if (!responseSchema) continue;

      out.push({ operationId, method, path: p, responseSchema });
    }
  }

  return out;
}

function pickResponseSchema(op: any) {
  // Берём “лучший” ответ: 200/201/204, иначе первый 2xx, иначе любой
  const responses = op.responses ?? {};
  const prefer = ["200", "201", "204"];
  for (const code of prefer) {
    const sch = schemaFromResponse(responses[code]);
    if (sch) return sch;
  }

  const codes = Object.keys(responses);
  const any2xx = codes.find((c) => /^2\d\d$/.test(c));
  if (any2xx) {
    const sch = schemaFromResponse(responses[any2xx]);
    if (sch) return sch;
  }

  for (const c of codes) {
    const sch = schemaFromResponse(responses[c]);
    if (sch) return sch;
  }
  return null;
}

function schemaFromResponse(resp: any) {
  if (!resp) return null;

  // Если нет content (например 204) вернуть простое значение
  const content = resp.content;
  if (!content) return { type: "null" };

  // предпочитаем json
  const json = content["application/json"] ?? content["application/*+json"];
  if (json?.schema) return json.schema;

  // как запасной вариант возьмём первый content-type
  const first = Object.values<any>(content)[0];
  if (first?.schema) return first.schema;

  return null;
}

function generateExample(schema: any, op: GeneratedOp) {
  // Тут можно прикрутить “умные подсказки” по названию operationId/пути.
  // Пока: schema-faker + faker + examples/default из схем.
  const data = jsf.generate(schema);

  // Минимальный “правдоподобный” патч: если видим поля по имени, улучшаем
  return deepPatchByFieldNames(data);
}

function deepPatchByFieldNames(value: any): any {
  if (Array.isArray(value)) return value.map(deepPatchByFieldNames);
  if (value && typeof value === "object") {
    const out: any = {};
    for (const [k, v] of Object.entries(value)) {
      out[k] = patchValue(k, deepPatchByFieldNames(v));
    }
    return out;
  }
  return value;
}

function patchValue(key: string, v: any) {
  const k = key.toLowerCase();

  if (v === "string") {
    if (k === "id" || k.endsWith("id")) return Faker.string.uuid();
    if (k.includes("email")) return Faker.internet.email();
    if (k.includes("phone")) return Faker.phone.number();
    if (k.includes("url")) return Faker.internet.url();
    if (k.includes("name")) return Faker.person.fullName();
    if (k.includes("title")) return Faker.lorem.sentence();
    if (k.includes("description")) return Faker.lorem.paragraph();
    if (k.includes("city")) return Faker.location.city();
    if (k.includes("country")) return Faker.location.country();
    if (k.includes("date") || k.includes("at")) return Faker.date.recent().toISOString();
    return Faker.lorem.word();
  }

  if (typeof v === "number") {
    if (k.includes("count") || k.includes("total")) return Faker.number.int({ min: 0, max: 1000 });
    if (k.includes("price") || k.includes("amount")) return Faker.number.float({ min: 0, max: 10000, fractionDigits: 2 });
    return v;
  }

  return v;
}

function ensureDir(dir: string) {
  fs.mkdirSync(dir, { recursive: true });
}

function sanitize(s: string) {
  return s.replace(/[^a-zA-Z0-9_]+/g, "_");
}

function toMswPath(openapiPath: string) {
  // OpenAPI: /users/{id} -> MSW: /users/:id
  return openapiPath.replace(/{([^}]+)}/g, ":$1");
}
